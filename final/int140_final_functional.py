"""
ปัญหาและคำตอบสำหรับการเตรียมสอบปลายภาค INT140
ส่วนที่ 2 - Functional - มีทั้งหมด 10 ข้อ
"""

from functools import reduce

""" ===============================================================
ปัญหาที่ 01: เขียนฟังก์ชัน 'func01' ที่รับลิสต์ของจำนวนเต็ม 
ฟังก์ชันนี้นับจำนวนเลขคู่ในลิสต์ 
(ฟังก์ชันนี้นับจำนวนเลขคู่ที่มีอยู่ในลิสต์)
เลขคู่คือจำนวนที่หารด้วย 2 ลงตัว (even_number % 2 == 0)
ฟังก์ชันนี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
เขียนฟังก์ชันนี้ในรูปแบบ Functional Style
ตัวอย่างเช่น:
func01([3, -2, 7, 0, 12, 6, -9]) -> 4
"""
# from functools import reduce
def func01(ls:list) -> int:
    return reduce(lambda count, _: count + 1,
                  filter(lambda element: element % 2 == 0, ls), 0)

""" ===============================================================
ปัญหาที่ 02: เขียนฟังก์ชัน 'func02' ที่รับลิสต์ของค่า 
(พารามิเตอร์ตัวแรก) และค่าหนึ่งค่า (พารามิเตอร์ตัวที่สอง)
ฟังก์ชันนี้นับจำนวนค่าที่อยู่ในลิสต์ (พารามิเตอร์ตัวแรก) 
ที่มีค่าน้อยกว่าค่าของพารามิเตอร์ตัวที่สอง 
(ฟังก์ชันนี้นับจำนวนค่าในลิสต์ที่มีค่าน้อยกว่าค่าของพารามิเตอร์ตัวที่สอง)
ฟังก์ชันนี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
ค่าที่อยู่ในลิสต์และค่าของพารามิเตอร์ตัวที่สองอาจเป็น 
จำนวนเต็ม, ทศนิยม, สตริง, หรือประเภทใด ๆ ที่สามารถเปรียบเทียบได้ด้วย < (น้อยกว่า)
เขียนฟังก์ชันนี้ในรูปแบบ Functional Style
ตัวอย่างเช่น:
func02([], 10) -> 0
func02(['hate', 'love', 'angry', 'fun', 'hunger'], 'happy') -> 2
func02([6, -12.5, 71, 4, 10], 9.9) -> 3
"""
# from functools import reduce
def func02(ls:list, value) -> int:
    return reduce(lambda count, _: count + 1,
                  filter(lambda element: element < value, ls), 0)

""" ===============================================================
ปัญหาที่ 03: เขียนฟังก์ชัน 'func03' ที่รับจำนวนเต็ม 
และส่งคืนลิสต์ที่มีจำนวนเต็มตั้งแต่ 0 ถึงตัวเลขนั้น 
พารามิเตอร์อาจเป็นบวก ลบ หรือศูนย์
ฟังก์ชันนี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
เขียนฟังก์ชันนี้ในรูปแบบ Recursive Style
ตัวอย่างเช่น:
func03(0) -> [0]
func03(4) -> [0, 1, 2, 3, 4]
func03(-3) -> [0, -1, -2, -3]
"""
def func03(num: int) -> list[int]:
    return [0] if num == 0 else func03(num + (1 if num < 0 else -1)) + [num]

""" ===============================================================
ปัญหาที่ 04: เขียนฟังก์ชัน 'func04' ที่รับลิสต์ของสตริง 
และส่งคืนผลรวมของความยาวของทุกสตริงในลิสต์ 
ฟังก์ชันนี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
เขียนฟังก์ชันนี้ในรูปแบบ Functional Style
ตัวอย่างเช่น:
func04(['one', 'two', 'three', 'four', 'five']) -> 19
"""
# from functools import reduce
def func04(ls: list[str]) -> int:
    return reduce(lambda a, i: a + i,
                  map(len, ls), 0)

""" ===============================================================
ปัญหาที่ 05: เขียนฟังก์ชัน 'func05' ที่รับลิสต์ของสตริง 
และส่งคืนสตริงที่รวมตัวอักษรตัวแรกของแต่ละสตริงในลิสต์ 
หากลิสต์ว่างเปล่าหรือมีแต่สตริงว่าง ให้ส่งคืนสตริงว่าง
ฟังก์ชันนี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
เขียนฟังก์ชันนี้ในรูปแบบ Functional Style
ตัวอย่างเช่น:
func05(['Strength', 'Weakness', 'Opportunity', 'Threat']) -> 'SWOT'
"""
# from functools import reduce
def func05(ls: list[str]) -> str:
    return reduce(lambda a, i: a + i,
                  map(lambda s: s[0] if len(s) > 0 else '', ls), '')

""" ===============================================================
ปัญหา 06: เขียนฟังก์ชัน 'func06' ที่รับลิสต์ที่มีค่าอยู่ภายใน 
ค่าในลิสต์อาจเป็น int, float, str หรือชนิดข้อมูลอื่นๆ ที่สามารถเปรียบเทียบด้วย < และ == ได้ 
ฟังก์ชันนี้นับจำนวนค่าที่มีค่าเท่ากับค่าที่น้อยที่สุดในลิสต์ 
และส่งคืนผลรวมที่นับได้
(ฟังก์ชันนี้ นับจำนวนของค่าในลิสต์ที่มีค่าเท่ากับค่าที่ต่ำที่สุดในลิสต์)
ตัวอย่าง:
หากลิสต์คือ [5, -3, 7, 6, -3, 5, -1, 5] ผลลัพธ์คือ 2
เพราะค่าที่น้อยที่สุดในลิสต์คือ -3 และมีค่า -3 อยู่ในลิสต์จำนวน 2 ค่า
หากลิสต์คือ ['is', 'am', 'are', 'do', 'am', 'is', 'have', 'am', 'are'] ผลลัพธ์คือ 3
เพราะค่าที่น้อยที่สุดคือ 'am' และมีค่า 'am' ในลิสต์จำนวน 3 ค่า
หากลิสต์เป็นลิสต์ว่าง (ไม่มีค่าใดเลย) จะไม่มีค่าที่น้อยที่สุด
ให้ส่งคืน 0 ฟังก์ชันนี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
เขียนฟังก์ชันนี้ในรูปแบบการเขียนแบบ Recursive
"""
def func06(ls: list, smallest=None, count=0):
    if len(ls) == 0:
        return count
    head = ls[0]
    tail = ls[1:]
    if smallest is None or head < smallest:  # หาก head เป็นค่าที่น้อยที่สุดใหม่
        return func06(tail, head, 1)        #     เรียกใช้ฟังก์ชันซ้ำ
                                            #     ด้วย tail, ค่าที่น้อยที่สุดใหม่, และเริ่มนับใหม่
    if head == smallest:                    # หาก head เท่ากับค่าที่น้อยที่สุดเดิม
        return func06(tail, smallest, count+1) #     เรียกใช้ฟังก์ชันซ้ำ
                                              #     ด้วย tail, ค่าที่น้อยที่สุดเดิม, และนับต่อ
    return func06(tail, smallest, count)    # มิฉะนั้น (head ไม่ใช่ค่าที่น้อยที่สุด)
                                            #     เรียกใช้ฟังก์ชันซ้ำ
                                            #     ด้วย tail, ค่าที่น้อยที่สุดเดิม, และจำนวนเดิม

""" ===============================================================
ปัญหา 07: เขียนฟังก์ชัน 'func07' ที่รับลิสต์ที่มีค่า 
และฟังก์ชันที่ส่งคืนค่าเป็น boolean (รับค่าและส่งคืน bool)
ฟังก์ชัน 'func07' ใช้ฟังก์ชัน boolean กับแต่ละค่าในลิสต์ 
นับผลลัพธ์ที่เป็น True และส่งคืนจำนวนที่นับได้
ฟังก์ชัน 'func07' นี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
เขียนฟังก์ชันนี้ในรูปแบบ Functional Style
ตัวอย่าง:
func07([6, 7, 8, 5, 4, 2, 9, 6, 3], lambda i: i % 2 == 0) -> 5
"""
from typing import Callable, Any
def func07(ls: list, f: Callable[[Any], bool]) -> int:
    return sum(map(lambda v: f(v), ls))

# วิธีแก้ในรูปแบบ Imperative Style --------------------
def func07im(ls: list, f: Callable[[Any], bool]) -> int:
    count = 0
    for v in ls:
        if f(v):
            count += 1
    return count

""" ===============================================================
ปัญหา 08: เขียนฟังก์ชัน 'func08' ที่รับลิสต์ที่มีค่า 
(ซึ่งอาจเป็น int, float, str หรือค่าที่เปรียบเทียบด้วย == และ < ได้)
ฟังก์ชันนี้ส่งคืนค่าที่น้อยที่สุดอันดับสองในลิสต์ 
หากลิสต์มีค่าน้อยกว่า 2 ค่า หรือค่าทั้งหมดในลิสต์เท่ากัน 
ให้ส่งคืน None
ห้ามใช้เทคนิคการเรียงลำดับหรือเทคนิคการลบค่าที่ซ้ำกัน (เช่น set/dict)
ฟังก์ชันนี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
เขียนฟังก์ชันนี้ในรูปแบบการเขียนแบบ Recursive
ตัวอย่าง:
func08([]) -> None
func08(['x']) -> None
func08(['a', 'a']) -> None
func08(['a', 'b']) -> 'b'
func08(['b', 'a']) -> 'b'
func08([300, -11, -20, -11, 300, -20, 50000, 300, 4000]) -> -11
"""
def func08(ls: list[Any]):
    def f(v, smallest=None, second=None):  # นิยามฟังก์ชันแบบ recursive
        if len(v) == 0:                    # หากไม่มีค่าในลิสต์ที่เหลือ
            return second                  #    ส่งคืนค่าที่น้อยที่สุดอันดับสอง
        if smallest is None or v[0] < smallest:  # หากหัวของลิสต์เป็นค่าที่น้อยที่สุดใหม่
            return f(v[1:], v[0], smallest)      #    ประมวลผลลิสต์ที่เหลือด้วยค่าที่น้อยที่สุดใหม่
        if smallest < v[0] and (second is None or v[0] < second):
                                               # หากหัวของลิสต์เป็นค่าที่น้อยที่สุดอันดับสองใหม่
            return f(v[1:], smallest, v[0])    #    ประมวลผลลิสต์ที่เหลือด้วยค่าที่น้อยที่สุดอันดับสองใหม่
        return f(v[1:], smallest, second)      # มิฉะนั้น ประมวลผลลิสต์ที่เหลือด้วยค่าที่มีอยู่เดิม
    return f(ls)