from functools import reduce

""" ===============================================================
ปัญหา_01: เขียนฟังก์ชัน 'func01' ที่รับตัวเลขสองตัว
ฟังก์ชันนี้จะคืนค่า True ถ้าตัวเลขตัวแรกน้อยกว่าตัวเลขตัวที่สอง
มิฉะนั้นจะคืนค่า False โดยฟังก์ชันนี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
ตัวอย่างเช่น
func01(10.1, 9.9) -> False
func01(5, 5.3) -> True
"""
def func01(num1,num2):
    return num1 < num2

""" ===============================================================
ปัญหา_02: เขียนฟังก์ชัน 'func02' ที่รับสตริงสองตัว 
ฟังก์ชันนี้จะคืนค่า True ถ้าสตริงตัวแรกเป็นส่วนหนึ่งของสตริงตัวที่สอง
มิฉะนั้นจะคืนค่า False โดยฟังก์ชันนี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
ตัวอย่างเช่น
func02('over', 'forever') -> False
func02('lie', 'believe') -> True
"""
def func02(str1,str2):
    return str1 in str2

""" ===============================================================
ปัญหา_03: เขียนฟังก์ชัน 'func03' ที่รับตัวเลขสองตัว 
ซึ่งเป็นความยาวของสองด้านที่ประกอบมุมฉากของสามเหลี่ยมมุมฉาก
ฟังก์ชันนี้คืนค่าความยาวของด้านตรงข้ามมุมฉาก
โดยฟังก์ชันนี้จะต้องตรวจสอบว่าพารามิเตอร์ทั้งสองตัวเป็นจำนวนบวก
หากพารามิเตอร์ใดไม่เป็นจำนวนบวก จะเกิดข้อผิดพลาด ValueError
ตัวอย่างเช่น
func03(4, 3) -> 5.0
func03(5, 12.0) -> 13.0
func03(-3.0, 4) -> ValueError
"""
def func03(side1,side2):
    if side1 <= 0 or side2 <= 0:
        raise ValueError()
    return(side1 ** 2 + side2 ** 2)**0.5

""" ===============================================================
ปัญหา_04: เขียนฟังก์ชัน 'func04' ที่รับลิสต์ของจำนวนเต็ม
ฟังก์ชันนี้จะนับจำนวนเลขคู่ในลิสต์
เลขคู่คือเลขที่หารด้วย 2 ลงตัว (even_number % 2 == 0)
ฟังก์ชันนี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
ตัวอย่างเช่น 
func04([3, -2, 7, 0, 12, 6, -9]) -> 4
"""
def func04(ls):
    counter = 0
    for i in ls:
        if i % 2 == 0:
            counter += 1
    return counter

""" ===============================================================
ปัญหา_05: เขียนฟังก์ชัน 'func05' ที่รับลิสต์ของค่า (พารามิเตอร์ตัวแรก) 
และค่าหนึ่งตัว (พารามิเตอร์ตัวที่สอง)
ฟังก์ชันนี้จะนับจำนวนค่าที่อยู่ในลิสต์ (พารามิเตอร์ตัวแรก)
ที่มีค่าน้อยกว่าค่าของพารามิเตอร์ตัวที่สอง
ฟังก์ชันนี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
ค่าที่อยู่ในลิสต์และค่าของพารามิเตอร์ตัวที่สองอาจเป็น
จำนวนเต็ม ทศนิยม สตริง หรือประเภทใดก็ตามที่สามารถเปรียบเทียบด้วย < ได้
ตัวอย่างเช่น
func05([], 10) -> 0
func05(['hate', 'love', 'angry', 'fun', 'hunger'], 'happy') -> 2
func05([6, -12.5, 71, 4, 10], 9.9) -> 3
"""
def func05(ls,value):
    counter = 0
    for i in ls:
        if i < value:
            counter += 1
    return counter

""" ===============================================================
ปัญหา_06: เขียนฟังก์ชัน 'func06' ที่รับจำนวนเต็มหนึ่งตัว
และคืนค่าลิสต์ที่มีตัวเลขทั้งหมดตั้งแต่ 0 ถึงตัวเลขนั้น
พารามิเตอร์อาจเป็นบวก ลบ หรือศูนย์
ฟังก์ชันนี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
ต้องใช้ลูปเพื่อเพิ่มแต่ละค่าเข้าไปในลิสต์
ตัวอย่างเช่น
func06(0) -> [0]
func06(4) -> [0, 1, 2, 3, 4]
func06(-3) -> [0, -1, -2, -3]
"""
def func06(num):
    step = 1
    if num < 0:
        step = -1
    value = 0
    result = [value]
    while value != num:
        value += step
        result.append(value)
    return result
""" ===============================================================
ปัญหา_07: เขียนฟังก์ชัน 'func07' ที่รับลิสต์ของสตริง
และคืนค่าผลรวมความยาวของสตริงทั้งหมดในลิสต์
ฟังก์ชันนี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
ตัวอย่างเช่น 
func07(['one', 'two', 'three', 'four', 'five']) -> 19
"""
def func07(ls):
    result = 0
    for i in ls:
        result += len(i)
    return result
""" ===============================================================
ปัญหา_08: เขียนฟังก์ชัน 'func08' ที่รับลิสต์ของสตริง
และคืนค่าสตริงที่เป็นผลรวมของตัวอักษรตัวแรกของแต่ละสตริงในลิสต์
หากลิสต์ว่างเปล่าหรือมีแต่สตริงที่ว่างเปล่า ให้คืนค่าสตริงว่าง
ฟังก์ชันนี้ไม่ตรวจสอบความถูกต้องของพารามิเตอร์
ตัวอย่างเช่น 
func08(['Strength', 'Weakness', 'Opportunity', 'Threat']) -> 'SWOT'
"""
def func08(ls):
    result = ""
    for i in ls:
        if len(i) > 0:
            result += i[0]
    return result

""" ===============================================================
ปัญหา_09: เขียนฟังก์ชัน 'func09' ที่รับลิสต์ของค่า
ค่าที่อยู่ในลิสต์อาจเป็น int, float, str, หรือประเภทใดก็ตามที่เปรียบเทียบด้วย < และ == ได้
ฟังก์ชันนี้จะนับจำนวนค่าที่มีค่าเท่ากับค่าที่น้อยที่สุดในลิสต์ และคืนค่าจำนวนที่นับได้
ตัวอย่างเช่น
func09([5, -3, 7, 6, -3, 5, -1, 5]) -> 2
func09(['is', 'am', 'are', 'do', 'am', 'is', 'have', 'am', 'are']) -> 3
"""
def func09(ls):  ## ฟังก์ชันนี้ไม่มี type hint
    if len(ls) == 0:  # ถ้าลิสต์ว่างเปล่า (ไม่มีสมาชิกเลย)
        return 0      # คืนค่า 0 ทันที
    counter = 0       # ตัวนับจำนวนสมาชิกที่มีค่าเท่ากับค่าต่ำสุด
    min_value = ls[0] # สมมติให้สมาชิกตัวแรกของลิสต์เป็นค่าต่ำสุด
    for value in ls:  # วนลูปผ่านสมาชิกแต่ละตัวในลิสต์
        if value < min_value:    # ถ้าพบสมาชิกที่มีค่าน้อยกว่าค่าต่ำสุดที่เคยเจอ
            min_value = value    #    อัปเดตค่าต่ำสุดใหม่
            counter = 1          #    เริ่มต้นตัวนับใหม่ที่ 1
        elif value == min_value: # แต่ถ้าสมาชิกมีค่าเท่ากับค่าต่ำสุดที่เคยเจอ
            counter += 1         #    เพิ่มตัวนับขึ้น 1
    return counter

""" ===============================================================
ปัญหา_10: เขียนฟังก์ชัน 'func10' ที่รับลิสต์ของค่าที่สามารถเปรียบเทียบด้วย < และ != ได้
และคืนค่าค่าที่น้อยที่สุดอันดับสองในลิสต์
ถ้าลิสต์ว่างเปล่าหรือมีค่าในลิสต์น้อยกว่า 2 ค่า จะคืนค่า None
ตัวอย่างเช่น
func10([6, -12.5, 71, 4, 4, 10]) -> 4
"""
def func10(ls):  ## ฟังก์ชันนี้ไม่มี type hint
    size = len(ls)       # หาขนาดของลิสต์
    if size < 2:         # ถ้าลิสต์มีสมาชิกน้อยกว่า 2 ตัว
        return None      # คืนค่า None เพราะไม่สามารถหาค่าสองค่าที่เล็กที่สุดได้
    smallest = ls[0]     # สมมติให้สมาชิกตัวแรกของลิสต์เป็นค่าที่เล็กที่สุด
    second = None        # ตั้งค่าที่เล็กเป็นอันดับสอง (ยังไม่มีค่า)
    for v in ls:                         # วนลูปผ่านสมาชิกแต่ละตัวในลิสต์
        if v < smallest:                 # ถ้าพบค่าสมาชิกที่เล็กกว่าค่าที่เล็กที่สุดปัจจุบัน
            second = smallest            #    เลื่อนค่าที่เล็กที่สุดปัจจุบันไปเป็นอันดับสอง
            smallest = v                 #    อัปเดตค่าที่เล็กที่สุดใหม่
        elif smallest < v and (second is None or v < second): # แต่ถ้าค่าสมาชิกใหญ่กว่าค่าที่เล็กที่สุด
                                          # และเป็นค่าที่เล็กกว่าค่าที่เล็กเป็นอันดับสองปัจจุบัน (หรือยังไม่มีค่าอันดับสอง)
            second = v                   #    ตั้งค่าสมาชิกนี้เป็นค่าที่เล็กเป็นอันดับสอง
    return second  # คืนค่าที่เล็กเป็นอันดับสอง
